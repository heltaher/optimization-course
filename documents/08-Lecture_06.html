<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lecture_06 ‚Äì  Design Optimization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<link href="../documents/09-Lecture_07.html" rel="next">
<link href="../documents/07-Lecture_05.html" rel="prev">
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-eef78bce6e6d37c27bc985c3ac861da9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../documents/images/logo.png" alt="Course Logo" class="navbar-logo light-content">
    <img src="../documents/images/logo.png" alt="Course Logo" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Design Optimization</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://youtu.be/qX4hefYY4h8"> <i class="bi bi-youtube" role="img" aria-label="Course Videos on YouTube">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/heltaher/optimization-course"> <i class="bi bi-github" role="img" aria-label="Course Material on GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../documents/02-about.html" aria-current="page"> <i class="bi bi-book" role="img" aria-label="Course Contents">
</i> 
<span class="menu-text">Course Overview:</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../documents/03-Lecture_01.html">üìñ Lectures</a></li><li class="breadcrumb-item"><a href="../documents/08-Lecture_06.html">Lecture 6: Numerical Methods</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">üè† Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/02-about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">üìö Course Contents</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">üìñ Lectures</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/03-Lecture_01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 1: Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/04-Lecture_02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 2: Problem Formulation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/05-Lecture_03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 3: Graphical Solution Method and Basic Optimization Concepts</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/06-Lecture_04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 4: Linear Programming</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/07-Lecture_05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 5: Lagrangian Methods</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/08-Lecture_06.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Lecture 6: Numerical Methods</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/09-Lecture_07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lecture 7: Applications</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/10-Study_Guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">üìù Study Guide</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../documents/11-questions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">‚ùì Quiz Questions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lecture-6-numerical-methods-for-constrained-optimum-design" id="toc-lecture-6-numerical-methods-for-constrained-optimum-design" class="nav-link active" data-scroll-target="#lecture-6-numerical-methods-for-constrained-optimum-design">Lecture 6: Numerical Methods for Constrained Optimum Design</a>
  <ul class="collapse">
  <li><a href="#basic-concepts-in-numerical-constrained-optimization" id="toc-basic-concepts-in-numerical-constrained-optimization" class="nav-link" data-scroll-target="#basic-concepts-in-numerical-constrained-optimization">Basic Concepts in Numerical Constrained Optimization</a></li>
  <li><a href="#sequential-linear-programming-slp" id="toc-sequential-linear-programming-slp" class="nav-link" data-scroll-target="#sequential-linear-programming-slp">Sequential Linear Programming (SLP)</a></li>
  <li><a href="#sequential-quadratic-programming-sqp" id="toc-sequential-quadratic-programming-sqp" class="nav-link" data-scroll-target="#sequential-quadratic-programming-sqp">Sequential Quadratic Programming (SQP)</a></li>
  <li><a href="#descent-functions-for-constrained-optimization" id="toc-descent-functions-for-constrained-optimization" class="nav-link" data-scroll-target="#descent-functions-for-constrained-optimization">Descent Functions for Constrained Optimization</a></li>
  <li><a href="#the-constrained-steepest-descent-csd-method" id="toc-the-constrained-steepest-descent-csd-method" class="nav-link" data-scroll-target="#the-constrained-steepest-descent-csd-method">The Constrained Steepest-Descent (CSD) Method</a></li>
  <li><a href="#solved-example-constrained-steepest-descent-method-first-iteration" id="toc-solved-example-constrained-steepest-descent-method-first-iteration" class="nav-link" data-scroll-target="#solved-example-constrained-steepest-descent-method-first-iteration">Solved Example: Constrained Steepest-Descent Method (First Iteration)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../documents/03-Lecture_01.html">üìñ Lectures</a></li><li class="breadcrumb-item"><a href="../documents/08-Lecture_06.html">Lecture 6: Numerical Methods</a></li></ol></nav></header>




<section id="lecture-6-numerical-methods-for-constrained-optimum-design" class="level1">
<h1>Lecture 6: Numerical Methods for Constrained Optimum Design</h1>
<p>In our previous lectures, we learned how to formulate an optimum design problem and, for specific cases, how to solve them analytically. We explored the graphical method for two-variable problems and Linear Programming for problems with linear objective functions and constraints. We also delved into Lagrangian methods, which provide the powerful Karush‚ÄìKuhn‚ÄìTucker (KKT) conditions for finding candidate optimal solutions for nonlinear problems.</p>
<p>However, most real-world engineering design problems are complex, involving <strong>nonlinear objective functions</strong> and <strong>nonlinear constraints</strong>, often with many design variables. For such problems, analytical solutions to the KKT conditions can be exceedingly difficult or impossible to obtain. This is where <strong>numerical methods for constrained optimum design</strong> become indispensable. These methods are iterative and use computational algorithms to systematically search for the optimum solution.</p>
<p>By the end of this lecture, you will understand the fundamental concepts behind numerical methods for constrained optimization, learn about Sequential Linear Programming (SLP) and Sequential Quadratic Programming (SQP) as prominent algorithms, and understand the role of descent functions and the Constrained Steepest-Descent (CSD) method.</p>
<section id="basic-concepts-in-numerical-constrained-optimization" class="level3">
<h3 class="anchored" data-anchor-id="basic-concepts-in-numerical-constrained-optimization">Basic Concepts in Numerical Constrained Optimization</h3>
<p>All numerical optimization methods, whether unconstrained or constrained, operate on an iterative principle. Starting from an initial design estimate, the design is progressively updated to reach an optimal point.</p>
<p>The general iterative update formula is: <span class="math inline">\(\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \Delta \mathbf{x}^{(k)}\)</span> or more commonly: <span class="math inline">\(\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + a_k \mathbf{d}^{(k)}\)</span></p>
<p>Where: * <span class="math inline">\(\mathbf{x}^{(k)}\)</span> is the design variable vector at the <span class="math inline">\(k\)</span>-th iteration. * <span class="math inline">\(\Delta \mathbf{x}^{(k)}\)</span> is the total change in design in the <span class="math inline">\(k\)</span>-th iteration. * <span class="math inline">\(a_k\)</span> is the <strong>step size</strong> (a scalar that determines how far to move along the search direction). * <span class="math inline">\(\mathbf{d}^{(k)}\)</span> is the <strong>search direction</strong> (a vector indicating the path to move from the current design point).</p>
<p>For constrained optimization, the challenge lies in determining an appropriate search direction and step size that not only improves the objective function but also respects all the constraints. There are generally two strategies for handling constraints:</p>
<ol type="1">
<li><strong>Feasible Path Strategy</strong>: Start from a feasible point and generate a sequence of designs that remain feasible throughout the iterations. When a constraint boundary is encountered, the search direction is modified to travel along a tangent to the boundary or deflects into the feasible region.</li>
<li><strong>Infeasible Path Strategy</strong>: Allow iterations to temporarily move into the infeasible region, with the algorithms designed to eventually guide the search back to the feasible set, ideally converging to an optimum on the constraint boundary.</li>
</ol>
<p>Most numerical algorithms for constrained problems decompose the solution process into two subproblems: 1. <strong>Search Direction Determination</strong>: Calculates a vector <span class="math inline">\(\mathbf{d}^{(k)}\)</span> based on the current design and the values and gradients of the problem functions. 2. <strong>Step Size Determination</strong>: Calculates a scalar <span class="math inline">\(a_k\)</span> by performing a one-dimensional search (line search) along the direction <span class="math inline">\(\mathbf{d}^{(k)}\)</span> to optimize a certain ‚Äúdescent function‚Äù.</p>
</section>
<section id="sequential-linear-programming-slp" class="level3">
<h3 class="anchored" data-anchor-id="sequential-linear-programming-slp">Sequential Linear Programming (SLP)</h3>
<p><strong>Sequential Linear Programming (SLP)</strong> methods are an intuitive approach to solving nonlinear programming (NLP) problems by iteratively approximating the original problem with a sequence of linear programs.</p>
<p>The basic idea is as follows: 1. Start with an initial design <span class="math inline">\(\mathbf{x}^{(k)}\)</span>. 2. <strong>Linearize</strong> the nonlinear objective function and all nonlinear constraints around the current design point using a first-order Taylor series expansion. This creates a linear approximation of the problem. 3. Formulate and solve this linearized problem as a <strong>Linear Programming (LP) subproblem</strong> to find a direction of design change, <span class="math inline">\(\mathbf{d}^{(k)}\)</span>. 4. Update the design using the calculated direction and a suitable step size. 5. Repeat the process until convergence.</p>
<section id="lp-subproblem-formulation" class="level4">
<h4 class="anchored" data-anchor-id="lp-subproblem-formulation">LP Subproblem Formulation</h4>
<p>At each iteration <span class="math inline">\(k\)</span>, the SLP algorithm defines an LP subproblem to find a design change <span class="math inline">\(\mathbf{d}^{(k)} = \Delta \mathbf{x}^{(k)}\)</span>. If the original problem is to minimize <span class="math inline">\(f(\mathbf{x})\)</span> subject to <span class="math inline">\(h_p(\mathbf{x})=0\)</span> and <span class="math inline">\(g_j(\mathbf{x})\le0\)</span>:</p>
<p><strong>Minimize</strong> <span class="math inline">\(f(\mathbf{x}^{(k)}) + \nabla f(\mathbf{x}^{(k)})^T \mathbf{d}\)</span> (this is a linear approximation of <span class="math inline">\(f(\mathbf{x}^{(k)} + \mathbf{d})\)</span>)</p>
<p><strong>Subject to:</strong> * <span class="math inline">\(h_p(\mathbf{x}^{(k)}) + \nabla h_p(\mathbf{x}^{(k)})^T \mathbf{d} = 0\)</span>, for <span class="math inline">\(p = 1, \ldots, p_{total}\)</span> (linearized equality constraints) * <span class="math inline">\(g_j(\mathbf{x}^{(k)}) + \nabla g_j(\mathbf{x}^{(k)})^T \mathbf{d} \le 0\)</span>, for <span class="math inline">\(j = 1, \ldots, m_{total}\)</span> (linearized inequality constraints) * <strong>Move Limits</strong>: To ensure that the linear approximations are reasonably accurate, explicit bounds (called move limits) are placed on the design changes <span class="math inline">\(\mathbf{d}\)</span>. <span class="math inline">\(-\Delta_{iL}^{(k)} \le d_i \le \Delta_{iU}^{(k)}\)</span>, for <span class="math inline">\(i = 1, \ldots, n\)</span> These limits are usually a fraction of the current design variable values. The variables <span class="math inline">\(d_i\)</span> are typically allowed to be positive or negative (free in sign) and are converted to standard LP form (non-negative) by replacing <span class="math inline">\(d_i = d_i^+ - d_i^-\)</span> with <span class="math inline">\(d_i^+, d_i^- \ge 0\)</span>.</p>
</section>
<section id="slp-algorithm-steps-simplified" class="level4">
<h4 class="anchored" data-anchor-id="slp-algorithm-steps-simplified">SLP Algorithm Steps (Simplified)</h4>
<ol type="1">
<li><strong>Initialize</strong>: Estimate a starting design <span class="math inline">\(\mathbf{x}^{(0)}\)</span>, set iteration counter <span class="math inline">\(k=0\)</span>, and specify convergence parameters <span class="math inline">\(\epsilon_1, \epsilon_2\)</span>.</li>
<li><strong>Evaluate</strong>: Calculate the objective function and all constraint functions and their gradients at <span class="math inline">\(\mathbf{x}^{(k)}\)</span>.</li>
<li><strong>Formulate LP Subproblem</strong>: Select appropriate move limits and construct the LP subproblem as described above.</li>
<li><strong>Solve LP Subproblem</strong>: Convert the LP subproblem to standard form (if necessary) and solve it for <span class="math inline">\(\mathbf{d}^{(k)}\)</span>.</li>
<li><strong>Check Convergence</strong>: If constraints are feasible within <span class="math inline">\(\epsilon_1\)</span> and the magnitude of <span class="math inline">\(\mathbf{d}^{(k)}\)</span> is below <span class="math inline">\(\epsilon_2\)</span>, stop.</li>
<li><strong>Update Design</strong>: <span class="math inline">\(\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + \mathbf{d}^{(k)}\)</span>. Set <span class="math inline">\(k = k+1\)</span> and go to Step 2.</li>
</ol>
<p><strong>Advantages and Drawbacks</strong>: SLP is conceptually simple and uses well-established LP solvers. However, it can suffer from slow convergence or oscillations if the linear approximations are poor or if the move limits are not chosen carefully.</p>
</section>
</section>
<section id="sequential-quadratic-programming-sqp" class="level3">
<h3 class="anchored" data-anchor-id="sequential-quadratic-programming-sqp">Sequential Quadratic Programming (SQP)</h3>
<p><strong>Sequential Quadratic Programming (SQP)</strong> methods are widely recognized as among the most robust and efficient algorithms for solving general nonlinear constrained optimization problems. They are based on solving a sequence of quadratic programming (QP) subproblems, which naturally incorporate second-order information about the problem functions.</p>
<p>The core idea of SQP is a generalization of Newton‚Äôs method for unconstrained optimization to constrained problems. At each iteration, an SQP method essentially performs two main steps:</p>
<ol type="1">
<li><strong>Search Direction Calculation</strong>: Determine a search direction <span class="math inline">\(\mathbf{d}^{(k)}\)</span> by solving a <strong>Quadratic Programming (QP) subproblem</strong>. This subproblem involves minimizing a quadratic approximation of the Lagrangian function (or a similar augmented function) subject to linear approximations of the original constraints.</li>
<li><strong>Step Size Calculation</strong>: Perform a line search along the calculated direction <span class="math inline">\(\mathbf{d}^{(k)}\)</span> to find an optimum step size <span class="math inline">\(a_k\)</span>, typically by minimizing a special <strong>descent function</strong> (also called a merit function).</li>
</ol>
<section id="qp-subproblem-formulation" class="level4">
<h4 class="anchored" data-anchor-id="qp-subproblem-formulation">QP Subproblem Formulation</h4>
<p>The QP subproblem at iteration <span class="math inline">\(k\)</span> (superscript <span class="math inline">\(k\)</span> omitted for simplicity) is typically formulated as:</p>
<p><strong>Minimize</strong> <span class="math inline">\(\nabla f(\mathbf{x})^T \mathbf{d} + \frac{1}{2}\mathbf{d}^T \mathbf{H} \mathbf{d}\)</span></p>
<p><strong>Subject to:</strong> * <span class="math inline">\(\nabla h_p(\mathbf{x})^T \mathbf{d} + h_p(\mathbf{x}) = 0\)</span>, for <span class="math inline">\(p = 1, \ldots, p_{total}\)</span> (linearized equality constraints) * <span class="math inline">\(\nabla g_j(\mathbf{x})^T \mathbf{d} + g_j(\mathbf{x}) \le 0\)</span>, for <span class="math inline">\(j = 1, \ldots, m_{total}\)</span> (linearized inequality constraints)</p>
<p>Where: * <span class="math inline">\(\nabla f(\mathbf{x})\)</span> is the gradient of the objective function. * <span class="math inline">\(\mathbf{H}\)</span> is the <strong>Hessian matrix of the Lagrangian function</strong> <span class="math inline">\(\nabla^2 L(\mathbf{x}, \mathbf{v}, \mathbf{u})\)</span> or, more commonly, an <strong>approximation</strong> of it. * The terms <span class="math inline">\(h_p(\mathbf{x})\)</span> and <span class="math inline">\(g_j(\mathbf{x})\)</span> in the constraints are the current violations/values of the constraints.</p>
<p><strong>Key features of the QP subproblem</strong>: * The QP subproblem is typically designed to be <strong>strictly convex</strong>, which ensures that if a solution exists, it is <strong>global and unique</strong> within the subproblem. * Solving the QP subproblem not only yields the search direction <span class="math inline">\(\mathbf{d}\)</span> but also provides the <strong>Lagrange multipliers</strong> for the constraints. These multipliers are essential for the line search and for updating the Hessian approximation.</p>
</section>
<section id="quasi-newton-hessian-approximation" class="level4">
<h4 class="anchored" data-anchor-id="quasi-newton-hessian-approximation">Quasi-Newton Hessian Approximation</h4>
<p>Calculating the exact Hessian matrix of the Lagrangian function can be computationally expensive or difficult for many engineering problems. To overcome this, SQP methods often employ <strong>quasi-Newton methods</strong> (like BFGS) to approximate the Hessian matrix. These methods use only first-order derivative information (gradients of the Lagrangian function at successive points) to build and update the Hessian approximation iteratively.</p>
<p>A crucial aspect is that the approximated Hessian matrix <span class="math inline">\(\mathbf{H}\)</span> is kept <strong>positive definite</strong> throughout the iterations. This ensures that the QP subproblem remains strictly convex, guaranteeing a unique and descent search direction.</p>
<p><strong>Advantages of SQP</strong>: * <strong>Fast Convergence</strong>: SQP methods typically exhibit a superlinear rate of convergence, meaning they converge very rapidly near the optimum. * <strong>Robustness</strong>: They can handle highly nonlinear problems with many variables and constraints. * <strong>Generality</strong>: Applicable to problems with both equality and inequality constraints. * The QP subproblem is related to the KKT conditions for the original problem.</p>
</section>
</section>
<section id="descent-functions-for-constrained-optimization" class="level3">
<h3 class="anchored" data-anchor-id="descent-functions-for-constrained-optimization">Descent Functions for Constrained Optimization</h3>
<p>In constrained optimization, simply reducing the objective function is not enough; the feasibility of the design must also be considered. <strong>Descent functions</strong> (also known as merit functions) combine the objective function and constraint violation into a single scalar function that can be minimized during the line search to determine the step size <span class="math inline">\(a_k\)</span>.</p>
<p>A commonly used descent function is <strong>Pshenichny‚Äôs descent function</strong>: <span class="math inline">\(\Phi(\mathbf{x}, R) = f(\mathbf{x}) + R V(\mathbf{x})\)</span></p>
<p>Where: * <span class="math inline">\(f(\mathbf{x})\)</span> is the objective function. * <span class="math inline">\(V(\mathbf{x})\)</span> is the <strong>maximum constraint violation</strong>, defined as: <span class="math inline">\(V(\mathbf{x}) = \max \{0, |h_k(\mathbf{x})| \text{ for all } k, g_j(\mathbf{x}) \text{ for all } j\}\)</span> (for <span class="math inline">\(g_j(\mathbf{x}) \le 0\)</span>) Basically, <span class="math inline">\(V(\mathbf{x})\)</span> is 0 if all constraints are satisfied, and positive if any constraint is violated, equal to the magnitude of the largest violation. * <span class="math inline">\(R\)</span> is a large <strong>positive penalty parameter</strong>. It ensures that constraint violations are heavily penalized, encouraging the algorithm to move towards the feasible region or reduce violations.</p>
<p>The line search then aims to find <span class="math inline">\(a_k\)</span> that minimizes <span class="math inline">\(\Phi(\mathbf{x}^{(k)} + a \mathbf{d}^{(k)}, R)\)</span>. The penalty parameter <span class="math inline">\(R\)</span> is typically adjusted during the optimization process; if constraint violations are not improving, <span class="math inline">\(R\)</span> is increased.</p>
</section>
<section id="the-constrained-steepest-descent-csd-method" class="level3">
<h3 class="anchored" data-anchor-id="the-constrained-steepest-descent-csd-method">The Constrained Steepest-Descent (CSD) Method</h3>
<p>The <strong>Constrained Steepest-Descent (CSD) method</strong> is a specific type of constrained optimization algorithm that modifies the steepest-descent direction to account for constraints. It is related to SQP in that it also involves solving a QP subproblem.</p>
<p>The philosophy of CSD is to find a search direction that is essentially the <strong>projection of the steepest-descent direction for the objective function onto the tangent hyperplane of the active constraints</strong>. This ensures that, for a small step, the design stays as close as possible to the active constraint boundaries while still improving the objective function.</p>
<p>The QP subproblem in the CSD method to determine the search direction <span class="math inline">\(\mathbf{d}\)</span> is formulated as: <strong>Minimize</strong> <span class="math inline">\(\nabla f(\mathbf{x})^T \mathbf{d} + \frac{1}{2}\mathbf{d}^T \mathbf{d}\)</span> (this is similar to minimizing the magnitude of <span class="math inline">\(\mathbf{d}\)</span> while pushing it in the negative gradient direction)</p>
<p><strong>Subject to:</strong> * <span class="math inline">\(\nabla h_p(\mathbf{x})^T \mathbf{d} + h_p(\mathbf{x}) = 0\)</span> (linearized equality constraints) * <span class="math inline">\(\nabla g_j(\mathbf{x})^T \mathbf{d} + g_j(\mathbf{x}) \le 0\)</span> (linearized inequality constraints)</p>
<p>The term <span class="math inline">\(\frac{1}{2}\mathbf{d}^T \mathbf{d}\)</span> in the objective is equivalent to minimizing <span class="math inline">\(\|\mathbf{d}\|^2\)</span>, which means finding the shortest vector <span class="math inline">\(\mathbf{d}\)</span> that satisfies the linearized constraints and has the greatest component in the direction of <span class="math inline">\(-\nabla f(\mathbf{x})\)</span>.</p>
<section id="csd-algorithm-steps-summarized-from" class="level4">
<h4 class="anchored" data-anchor-id="csd-algorithm-steps-summarized-from">CSD Algorithm Steps (Summarized from)</h4>
<ol type="1">
<li><strong>Initialize</strong>: Set initial design <span class="math inline">\(\mathbf{x}^{(0)}\)</span>, iteration counter <span class="math inline">\(k=0\)</span>, penalty parameter <span class="math inline">\(R_0\)</span>, and convergence parameters <span class="math inline">\(\epsilon_1, \epsilon_2\)</span>.</li>
<li><strong>Evaluate</strong>: Calculate objective, constraint functions, and their gradients at <span class="math inline">\(\mathbf{x}^{(k)}\)</span>.</li>
<li><strong>Define and Solve QP Subproblem</strong>: Construct and solve the QP subproblem for the search direction <span class="math inline">\(\mathbf{d}^{(k)}\)</span> and Lagrange multipliers <span class="math inline">\(\mathbf{u}^{(k)}\)</span> and <span class="math inline">\(\mathbf{v}^{(k)}\)</span>.</li>
<li><strong>Check Convergence</strong>: If <span class="math inline">\(\|\mathbf{d}^{(k)}\| \le \epsilon_2\)</span> and the point is feasible, stop.</li>
<li><strong>Step Size Determination</strong>: Find an acceptable step size <span class="math inline">\(a_k\)</span> by performing a line search on Pshenichny‚Äôs descent function <span class="math inline">\(\Phi(\mathbf{x}, R)\)</span> along <span class="math inline">\(\mathbf{d}^{(k)}\)</span>.</li>
<li><strong>Update Design</strong>: <span class="math inline">\(\mathbf{x}^{(k+1)} = \mathbf{x}^{(k)} + a_k \mathbf{d}^{(k)}\)</span>.</li>
<li><strong>Update Penalty Parameter</strong>: If the maximum constraint violation has not improved, increase <span class="math inline">\(R\)</span>.</li>
<li>Set <span class="math inline">\(k = k+1\)</span> and go to Step 2.</li>
</ol>
<p>The CSD algorithm has been proven to converge to a KKT point for the general constrained optimization problem. It is a robust method, and its rate of convergence can be improved by including second-order information in the QP subproblem.</p>
</section>
</section>
<section id="solved-example-constrained-steepest-descent-method-first-iteration" class="level3">
<h3 class="anchored" data-anchor-id="solved-example-constrained-steepest-descent-method-first-iteration">Solved Example: Constrained Steepest-Descent Method (First Iteration)</h3>
<p>Let‚Äôs illustrate the first iteration of the CSD method for a nonlinear constrained problem.</p>
<p><strong>Problem Statement:</strong> Minimize the function <span class="math inline">\(f(x_1, x_2) = x_1^2 + x_2^2 - 3x_1x_2\)</span> Subject to: <span class="math inline">\(g_1(x_1, x_2) = \frac{1}{6}x_1^2 + \frac{1}{6}x_2^2 - 1 \le 0\)</span> <span class="math inline">\(g_2(x_1, x_2) = -x_1 \le 0 \quad (\text{i.e., } x_1 \ge 0)\)</span> <span class="math inline">\(g_3(x_1, x_2) = -x_2 \le 0 \quad (\text{i.e., } x_2 \ge 0)\)</span></p>
<p><strong>Initial Data:</strong> * Starting design <span class="math inline">\(\mathbf{x}^{(0)} = (1, 1)\)</span>. * Penalty parameter <span class="math inline">\(R_0 = 10\)</span>. * Step reduction parameter <span class="math inline">\(\gamma = 0.5\)</span> (used in the descent condition, as per source example).</p>
<section id="iteration-1-k-0" class="level4">
<h4 class="anchored" data-anchor-id="iteration-1-k-0">Iteration 1 (k = 0)</h4>
<p><strong>Step 1: Evaluate Cost and Constraint Functions and Their Gradients at <span class="math inline">\(\mathbf{x}^{(0)} = (1, 1)\)</span></strong></p>
<ul>
<li><strong>Objective Function</strong>: <span class="math inline">\(f(1, 1) = (1)^2 + (1)^2 - 3(1)(1) = 1 + 1 - 3 = -1\)</span>.</li>
<li><strong>Constraint Functions</strong>: <span class="math inline">\(g_1(1, 1) = \frac{1}{6}(1)^2 + \frac{1}{6}(1)^2 - 1 = \frac{1}{6} + \frac{1}{6} - 1 = \frac{2}{6} - 1 = \frac{1}{3} - 1 = -\frac{2}{3} \le 0\)</span> (inactive). <span class="math inline">\(g_2(1, 1) = -1 \le 0\)</span> (inactive). <span class="math inline">\(g_3(1, 1) = -1 \le 0\)</span> (inactive).</li>
<li><strong>Gradients</strong>: <span class="math inline">\(\nabla f(\mathbf{x}) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2} \right)^T = (2x_1 - 3x_2, 2x_2 - 3x_1)^T\)</span>. At <span class="math inline">\(\mathbf{x}^{(0)} = (1, 1)\)</span>, <span class="math inline">\(\nabla f(1, 1) = (2(1) - 3(1), 2(1) - 3(1))^T = (-1, -1)^T\)</span>. <span class="math inline">\(\nabla g_1(\mathbf{x}) = \left( \frac{\partial g_1}{\partial x_1}, \frac{\partial g_1}{\partial x_2} \right)^T = \left( \frac{1}{3}x_1, \frac{1}{3}x_2 \right)^T\)</span>. At <span class="math inline">\(\mathbf{x}^{(0)} = (1, 1)\)</span>, <span class="math inline">\(\nabla g_1(1, 1) = \left( \frac{1}{3}, \frac{1}{3} \right)^T\)</span>. <span class="math inline">\(\nabla g_2(\mathbf{x}) = (-1, 0)^T\)</span>. <span class="math inline">\(\nabla g_3(\mathbf{x}) = (0, -1)^T\)</span>.</li>
</ul>
<p><strong>Step 2: Define and Solve the QP Subproblem for the Search Direction <span class="math inline">\(\mathbf{d}^{(0)}\)</span></strong></p>
<p>Since all constraints are inactive at <span class="math inline">\(\mathbf{x}^{(0)}\)</span>, the QP subproblem simplifies to an unconstrained minimization: <strong>Minimize</strong> <span class="math inline">\(\nabla f(\mathbf{x}^{(0)})^T \mathbf{d} + \frac{1}{2}\mathbf{d}^T \mathbf{I} \mathbf{d}\)</span> <strong>Minimize</strong> <span class="math inline">\((-1)d_1 + (-1)d_2 + \frac{1}{2}(d_1^2 + d_2^2)\)</span></p>
<p>To find the minimum, we set the partial derivatives with respect to <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> to zero: <span class="math inline">\(\frac{\partial}{\partial d_1} (-d_1 - d_2 + \frac{1}{2}d_1^2 + \frac{1}{2}d_2^2) = -1 + d_1 = 0 \Rightarrow d_1 = 1\)</span>. <span class="math inline">\(\frac{\partial}{\partial d_2} (-d_1 - d_2 + \frac{1}{2}d_1^2 + \frac{1}{2}d_2^2) = -1 + d_2 = 0 \Rightarrow d_2 = 1\)</span>.</p>
<p>So, the search direction is <span class="math inline">\(\mathbf{d}^{(0)} = (1, 1)^T\)</span>. The Lagrange multipliers for the constraints from this subproblem are all zero, as none are active.</p>
<p><strong>Step 3: Step Size Determination using Pshenichny‚Äôs Descent Function</strong></p>
<p>We need to find an acceptable step size <span class="math inline">\(a_0\)</span> along <span class="math inline">\(\mathbf{d}^{(0)}\)</span>. * <strong>Current Descent Function Value</strong>: <span class="math inline">\(\Phi_0 = f(\mathbf{x}^{(0)}) + R_0 V(\mathbf{x}^{(0)})\)</span>. * <span class="math inline">\(V(\mathbf{x}^{(0)}) = \max(0, g_1(1,1), g_2(1,1), g_3(1,1)) = \max(0, -2/3, -1, -1) = 0\)</span>. * <span class="math inline">\(\Phi_0 = -1 + 10(0) = -1\)</span>. * <strong>Descent Condition Parameter</strong>: <span class="math inline">\(b_0 = \gamma \|\mathbf{d}^{(0)}\|^2 = 0.5 \left( (1)^2 + (1)^2 \right) = 0.5(2) = 1\)</span>. * <strong>Trial Step Sizes</strong>: We use <span class="math inline">\(t_j = (0.5)^j\)</span> for <span class="math inline">\(j=0, 1, 2, \ldots\)</span>.</p>
<pre><code>**Trial 1: $t_0 = 1$**
*   **Trial Design**: $\mathbf{x}^{(1,0)} = \mathbf{x}^{(0)} + t_0 \mathbf{d}^{(0)} = (1,1) + 1(1,1) = (2,2)$.
*   **Evaluate Functions at $\mathbf{x}^{(1,0)} = (2,2)$**:
    $f(2,2) = (2)^2 + (2)^2 - 3(2)(2) = 4 + 4 - 12 = -4$.
    $g_1(2,2) = \frac{1}{6}(2)^2 + \frac{1}{6}(2)^2 - 1 = \frac{8}{6} - 1 = \frac{4}{3} - 1 = \frac{1}{3}$.
    Since $g_1(2,2) = 1/3 &gt; 0$, this constraint is violated.
*   **Maximum Constraint Violation**: $V(\mathbf{x}^{(1,0)}) = \max(0, 1/3, -2, -2) = 1/3$.
*   **Descent Function Value**: $\Phi_{1,0} = f(\mathbf{x}^{(1,0)}) + R_0 V(\mathbf{x}^{(1,0)}) = -4 + 10(1/3) = -4 + 10/3 = -\frac{12}{3} + \frac{10}{3} = -\frac{2}{3} \approx -0.667$.
*   **Check Descent Condition**: $\Phi_{1,0} \le \Phi_0 - t_0 b_0$.
    $-\frac{2}{3} \le -1 - 1(1) = -2$. This inequality is **False** ($-0.667 \not\le -2$). So, $t_0=1$ is not acceptable.

**Trial 2: $t_1 = 0.5$**
*   **Trial Design**: $\mathbf{x}^{(1,1)} = \mathbf{x}^{(0)} + t_1 \mathbf{d}^{(0)} = (1,1) + 0.5(1,1) = (1.5, 1.5)$.
*   **Evaluate Functions at $\mathbf{x}^{(1,1)} = (1.5, 1.5)$**:
    $f(1.5, 1.5) = (1.5)^2 + (1.5)^2 - 3(1.5)(1.5) = 2.25 + 2.25 - 6.75 = -2.25$.
    $g_1(1.5, 1.5) = \frac{1}{6}(1.5)^2 + \frac{1}{6}(1.5)^2 - 1 = \frac{1}{6}(2.25) + \frac{1}{6}(2.25) - 1 = \frac{4.5}{6} - 1 = 0.75 - 1 = -0.25 \le 0$ (inactive).
*   **Maximum Constraint Violation**: $V(\mathbf{x}^{(1,1)}) = \max(0, -0.25, -1.5, -1.5) = 0$.
*   **Descent Function Value**: $\Phi_{1,1} = f(\mathbf{x}^{(1,1)}) + R_0 V(\mathbf{x}^{(1,1)}) = -2.25 + 10(0) = -2.25$.
*   **Check Descent Condition**: $\Phi_{1,1} \le \Phi_0 - t_1 b_0$.
    $-2.25 \le -1 - 0.5(1) = -1.5$. This inequality is **True**. So, $t_1=0.5$ is acceptable.</code></pre>
<p><strong>Step 4 &amp; 5: Update Design and Set Next Iteration</strong> * The acceptable step size is <span class="math inline">\(a_0 = 0.5\)</span>. * The new design is <span class="math inline">\(\mathbf{x}^{(1)} = (1.5, 1.5)\)</span>. * Set <span class="math inline">\(k=1\)</span> and proceed to the next iteration.</p>
<p>This concludes the first iteration of the Constrained Steepest-Descent method, moving the design from <span class="math inline">\((1,1)\)</span> to <span class="math inline">\((1.5, 1.5)\)</span>, reducing the objective function value from -1 to -2.25, and maintaining feasibility.</p>
<p>This concludes our lecture on Numerical Methods for Constrained Optimum Design. We have covered fundamental concepts and two of the most popular algorithms, SLP and SQP, along with the CSD method. In the next lecture, we will explore various applications of design optimization in real-world engineering scenarios.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../documents/07-Lecture_05.html" class="pagination-link" aria-label="Lecture 5: Lagrangian Methods">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Lecture 5: Lagrangian Methods</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../documents/09-Lecture_07.html" class="pagination-link" aria-label="Lecture 7: Applications">
        <span class="nav-page-text">Lecture 7: Applications</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>